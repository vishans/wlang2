#include <iostream>
#include <fstream>
#include "../ast/ast.h"
#include "../globals/globals.h"
#include "../helper/helper.h"
#include "../cli11/CLI11.hpp"

// Declare functions generated by Flex and Bison
extern int yyparse();
extern FILE *yyin;

extern int yydebug;

// The parsed workout object
extern Workout *parsedWorkout;

void cleanUp();

int main(int argc, char **argv) {
    CLI::App app{"W Compiler"};

    std::string input_file;
    app.add_option("file", input_file, "The .w file to compile");

    bool print_output = false;
    app.add_flag("-p,--print", print_output, "Print output to standard output");

    bool csv_output = true;
    app.add_flag("-c,--csv", csv_output, "Generate CSV output (enabled by default)");

    std::string output_file;
    app.add_option("-o,--output", output_file, "Specify output CSV file name");

    bool version = false;
    app.add_flag("-v,--version", version, "Print compiler version");

    CLI11_PARSE(app, argc, argv);

    if (version) {
    // Print version and exit
        std::cout << "W Compiler Version 1.0.1" << std::endl;
        return 0;
    }

    if(input_file.empty()){
        std::cout << "A .w file is required";
        return 1;
    }

    // If --print is use without --csv, we disable the csv output and only print to std output
    if (print_output && !app.count("--csv")) {
        csv_output = false;
    }


    yydebug = 0;
    
    fp = input_file;
    FILE *file = fopen(input_file.c_str(), "r");
    if (!file) {
        std::cerr << "Could not open file: " << argv[1] << std::endl;
        return 1;
    }
    // Set the input stream for the lexer
    yyin = file;
   

    initializeMaps();
    // Parse the input
    if (yyparse() == 0) {
        // If parsing succeeds, print the parsed workout details
        if (parsedWorkout) {

            if(print_output){
                parsedWorkout->printWorkout();

                // Show constants
                if(!constNameToValue.empty()){
                    std::cout << std::endl << "Constants: " << std::endl;
                    for(const auto &pair : constNameToValue){
                        std::cout << "    "  << pair.first <<  " = " << pair.second << std::endl;
                    }
                }
            }

            std::string csvFileName;

            if(csv_output){

                if(output_file.empty()){
                    std::size_t lastDotPos = input_file.find_last_of(".");

                    if(lastDotPos != 0 && lastDotPos != std::string::npos){
                        std::string baseName = input_file.substr(0, lastDotPos);
                        csvFileName = baseName + ".csv";

                    }else{
                        std::cout << "Bad filename.";
                        cleanUp();
                        return 1;
                    }
                }
                else{
                    csvFileName = output_file;
                }

                std::ofstream outfile(csvFileName);

                if(outfile.is_open()){
                    outfile <<  parsedWorkout->csv();
                    std::cout << csvFileName << " has successfully been created!" << std::endl;
                   
                }
                else{
                    std::cout << "An error occurred. Could not produce .csv file.";
                    cleanUp();
                    return 1;
                }
                

            }
            
        } else {
            std::cerr << "No workout data was parsed." << std::endl;
            cleanUp();
            return 1;
        }
    } else {
        std::cerr << "Parsing failed!" << std::endl;
        cleanUp();
        return 1;
    }

    cleanUp();
}

void cleanUp(){
     // Clean up
    if (parsedWorkout) {
        delete parsedWorkout;
    }

    // Close the input file if opened
    if (yyin) {
        fclose(yyin);
    }

}